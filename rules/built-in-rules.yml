# Built-in Security Rules for Security Code Review Agent
# Version: 1.0.0
# Last Updated: 2024-01-15

# This file contains comprehensive built-in security rules that check for common
# vulnerabilities based on OWASP Top 10, CWE standards, and security best practices.

rules:
  # =============================================================================
  # INJECTION VULNERABILITIES
  # =============================================================================

  - rule_id: BUILTIN-SQL-001
    title: "SQL Injection - String Concatenation"
    description: "SQL query constructed using string concatenation or formatting with user input, making it vulnerable to SQL injection attacks"
    severity: CRITICAL
    category: security
    cwe: CWE-89
    owasp: "A03:2021 - Injection"

    compliance:
      - framework: PCI_DSS
        requirement: "6.5.1"
        description: "Injection flaws, particularly SQL injection"
      - framework: OWASP_TOP_10
        requirement: "A03:2021"
        description: "Injection"

    detection:
      patterns:
        - pattern: '(execute|exec|executemany|cursor\.execute)\s*\([^)]*%s[^)]*%'
          language: python
          confidence: 0.8
          description: "Python string formatting in SQL execution"

        - pattern: '(execute|exec|executemany|cursor\.execute)\s*\([^)]*\.format\('
          language: python
          confidence: 0.9
          description: "Python .format() in SQL execution"

        - pattern: '(execute|exec|executemany|cursor\.execute)\s*\([^)]*f["\']'
          language: python
          confidence: 0.9
          description: "Python f-string in SQL execution"

        - pattern: '(SELECT|INSERT|UPDATE|DELETE|DROP|CREATE).*\+.*\+'
          confidence: 0.7
          description: "SQL keywords with string concatenation"

        - pattern: 'Statement\s*=\s*[^;]*\+[^;]*\+'
          language: java
          confidence: 0.7
          description: "Java SQL statement concatenation"

        - pattern: 'createQuery\([^)]*\+[^)]*\)'
          language: java
          confidence: 0.8
          description: "JPA query concatenation"

    scope:
      file_patterns:
        - "**/*.py"
        - "**/*.java"
        - "**/*.js"
        - "**/*.ts"
        - "**/*.php"
        - "**/*.rb"
      languages:
        - python
        - java
        - javascript
        - typescript
        - php
        - ruby

    remediation:
      description: |
        Use parameterized queries (prepared statements) instead of string concatenation.
        This separates SQL code from data, preventing injection attacks.

      steps:
        - "Replace string concatenation with parameterized queries"
        - "Use prepared statements or ORM query builders"
        - "Never trust user input in SQL queries"
        - "Validate and sanitize all input as defense in depth"

      code_examples:
        - language: python
          insecure: |
            # INSECURE - SQL Injection vulnerability
            username = request.GET.get('username')
            query = f"SELECT * FROM users WHERE username = '{username}'"
            cursor.execute(query)

          secure: |
            # SECURE - Parameterized query
            username = request.GET.get('username')
            query = "SELECT * FROM users WHERE username = %s"
            cursor.execute(query, (username,))

        - language: java
          insecure: |
            // INSECURE - SQL Injection vulnerability
            String username = request.getParameter("username");
            String query = "SELECT * FROM users WHERE username = '" + username + "'";
            Statement stmt = connection.createStatement();
            ResultSet rs = stmt.executeQuery(query);

          secure: |
            // SECURE - Prepared statement
            String username = request.getParameter("username");
            String query = "SELECT * FROM users WHERE username = ?";
            PreparedStatement pstmt = connection.prepareStatement(query);
            pstmt.setString(1, username);
            ResultSet rs = pstmt.executeQuery();

    references:
      - "https://owasp.org/www-community/attacks/SQL_Injection"
      - "https://cwe.mitre.org/data/definitions/89.html"
      - "https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html"

  - rule_id: BUILTIN-CMD-001
    title: "Command Injection Vulnerability"
    description: "System command execution with unsanitized user input allows attackers to execute arbitrary commands"
    severity: CRITICAL
    category: security
    cwe: CWE-78
    owasp: "A03:2021 - Injection"

    compliance:
      - framework: PCI_DSS
        requirement: "6.5.1"
        description: "Injection flaws"

    detection:
      patterns:
        - pattern: 'os\.system\([^)]*\+[^)]*\)'
          language: python
          confidence: 0.9
          description: "Python os.system with concatenation"

        - pattern: 'subprocess\.(call|run|Popen)\([^)]*shell\s*=\s*True'
          language: python
          confidence: 0.8
          description: "Python subprocess with shell=True"

        - pattern: 'exec\([^)]*\+[^)]*\)'
          language: javascript
          confidence: 0.9
          description: "JavaScript exec with concatenation"

        - pattern: 'Runtime\.getRuntime\(\)\.exec\([^)]*\+[^)]*\)'
          language: java
          confidence: 0.9
          description: "Java Runtime.exec with concatenation"

        - pattern: 'shell_exec\([^)]*\$[^)]*\)'
          language: php
          confidence: 0.8
          description: "PHP shell_exec with variables"

    scope:
      file_patterns:
        - "**/*.py"
        - "**/*.js"
        - "**/*.java"
        - "**/*.php"
      languages:
        - python
        - javascript
        - java
        - php

    remediation:
      description: |
        Avoid executing system commands with user input. If necessary, use argument
        arrays instead of shell strings, and strictly validate/whitelist input.

      steps:
        - "Use argument arrays instead of shell strings"
        - "Disable shell interpretation when possible"
        - "Whitelist allowed commands and arguments"
        - "Validate and sanitize all input strictly"

      code_examples:
        - language: python
          insecure: |
            # INSECURE - Command injection vulnerability
            filename = request.GET.get('filename')
            os.system(f"cat {filename}")

          secure: |
            # SECURE - Using argument array without shell
            import subprocess
            filename = request.GET.get('filename')
            # Validate filename against whitelist
            if not re.match(r'^[a-zA-Z0-9_\-\.]+$', filename):
                raise ValueError("Invalid filename")
            subprocess.run(['cat', filename], check=True)

    references:
      - "https://owasp.org/www-community/attacks/Command_Injection"
      - "https://cwe.mitre.org/data/definitions/78.html"

  - rule_id: BUILTIN-XSS-001
    title: "Cross-Site Scripting (XSS) - Unescaped Output"
    description: "User input rendered to HTML without proper encoding allows XSS attacks"
    severity: HIGH
    category: security
    cwe: CWE-79
    owasp: "A03:2021 - Injection"

    compliance:
      - framework: PCI_DSS
        requirement: "6.5.7"
        description: "Cross-site scripting (XSS)"

    detection:
      patterns:
        - pattern: '\.innerHTML\s*=\s*[^"]'
          language: javascript
          confidence: 0.7
          description: "Direct assignment to innerHTML"

        - pattern: 'document\.write\('
          language: javascript
          confidence: 0.8
          description: "Use of document.write"

        - pattern: '\$\([^)]*\)\.html\([^)]*\)'
          language: javascript
          confidence: 0.6
          description: "jQuery .html() method"

        - pattern: 'dangerouslySetInnerHTML'
          language: javascript
          confidence: 0.7
          description: "React dangerouslySetInnerHTML"

        - pattern: 'echo\s+\$_(GET|POST|REQUEST)\['
          language: php
          confidence: 0.8
          description: "PHP echoing user input directly"

    scope:
      file_patterns:
        - "**/*.js"
        - "**/*.jsx"
        - "**/*.ts"
        - "**/*.tsx"
        - "**/*.php"
        - "**/*.html"
      languages:
        - javascript
        - typescript
        - php

    remediation:
      description: |
        Always encode user input before rendering to HTML. Use framework-provided
        encoding functions or text content APIs that automatically encode.

      steps:
        - "Use text content APIs (textContent, innerText) instead of innerHTML"
        - "Apply context-appropriate encoding (HTML, JavaScript, URL)"
        - "Use framework auto-escaping features (React's JSX, Vue templates)"
        - "Implement Content Security Policy (CSP) headers"

      code_examples:
        - language: javascript
          insecure: |
            // INSECURE - XSS vulnerability
            const username = getUserInput();
            document.getElementById('greeting').innerHTML = 'Hello ' + username;

          secure: |
            // SECURE - Using textContent (auto-encodes)
            const username = getUserInput();
            document.getElementById('greeting').textContent = 'Hello ' + username;

    references:
      - "https://owasp.org/www-community/attacks/xss/"
      - "https://cwe.mitre.org/data/definitions/79.html"
      - "https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html"

  # =============================================================================
  # AUTHENTICATION & SESSION MANAGEMENT
  # =============================================================================

  - rule_id: BUILTIN-AUTH-001
    title: "Hardcoded Credentials"
    description: "Hardcoded passwords, API keys, or secrets in source code"
    severity: CRITICAL
    category: security
    cwe: CWE-798
    owasp: "A07:2021 - Identification and Authentication Failures"

    compliance:
      - framework: PCI_DSS
        requirement: "8.2.1"
        description: "Do not use vendor-supplied defaults for system passwords"
      - framework: SOC2
        requirement: "CC6.1"
        description: "Logical and physical access controls"

    detection:
      patterns:
        - pattern: '(password|passwd|pwd)\s*=\s*["\'][^"\']{6,}["\']'
          confidence: 0.8
          description: "Hardcoded password variable"

        - pattern: '(api_key|apikey|api-key|apiKey)\s*=\s*["\'][A-Za-z0-9]{20,}["\']'
          confidence: 0.9
          description: "Hardcoded API key"

        - pattern: '(secret|secret_key|secretKey)\s*=\s*["\'][^"\']{16,}["\']'
          confidence: 0.8
          description: "Hardcoded secret"

        - pattern: '(token|auth_token|authToken)\s*=\s*["\'][A-Za-z0-9]{32,}["\']'
          confidence: 0.8
          description: "Hardcoded authentication token"

        - pattern: { confidence: 0.9, description: "Hardcoded Bearer token" } ][ A-Z0-9]{20}["\']'
          confidence: 0.9
          description: "AWS Access Key ID"

        - pattern: '(aws_secret_access_key|AWS_SECRET_ACCESS_KEY|secretAccessKey)\s*[:=]\s*["\'][A-Za-z0-9/+=]{40}["\']'
          confidence: 0.85
          description: "AWS Secret Access Key (40 characters)"

        - pattern: '(aws_session_token|AWS_SESSION_TOKEN|sessionToken)\s*[:=]\s*["\'][A-Za-z0-9/+=]{100,}["\']'
          confidence: 0.85
          description: "AWS Session Token"

        - pattern: '(AWSAccessKeyId)=[A-Z0-9]+'
          confidence: 0.95
          description: "AWS Access Key in URL parameter"

    scope:
      file_patterns:
        - "**/*.py"
        - "**/*.js"
        - "**/*.java"
        - "**/*.go"
        - "**/*.rb"
        - "**/*.php"
        - "**/*.ts"
        - "**/*.yml"
        - "**/*.yaml"
        - "**/*.json"
      exclude:
        - "**/test/**"
        - "**/tests/**"
        - "**/*.test.*"
        - "**/*.spec.*"

    false_positive_indicators:
      - pattern: 'example|sample|dummy|placeholder|test|mock'
        description: "Example or test credentials"

    suppression_comment: "# nosec: hardcoded-credential"

    remediation:
      description: |
        Never hardcode credentials in source code. Use environment variables,
        configuration files (not in version control), or secret management systems.

      steps:
        - "Remove hardcoded credentials from source code"
        - "Store credentials in environment variables"
        - "Use secret management systems (Vault, AWS Secrets Manager, Azure Key Vault)"
        - "Add credential files to .gitignore"
        - "Rotate any exposed credentials immediately"

      code_examples:
        - language: python
          insecure: |
            # INSECURE - Hardcoded credentials
            API_KEY = "sk_live_1234567890abcdef"
            DATABASE_PASSWORD = "hardcoded_password_123"

          secure: |
            # SECURE - Environment variables
            import os

            API_KEY = os.environ.get('API_KEY')
            DATABASE_PASSWORD = os.environ.get('DATABASE_PASSWORD')

            if not API_KEY:
                raise ValueError("API_KEY environment variable not set")

    references:
      - "https://cwe.mitre.org/data/definitions/798.html"
      - "https://owasp.org/www-community/vulnerabilities/Use_of_hard-coded_password"

  - rule_id: BUILTIN-CRYPTO-002
    title: "Weak Cryptographic Hash - MD5/SHA1"
    description: "Use of weak cryptographic hash functions (MD5, SHA1) for security purposes"
    severity: HIGH
    category: security
    cwe: CWE-326
    owasp: "A02:2021 - Cryptographic Failures"

    detection:
      patterns:
        - pattern: 'hashlib\.(md5|sha1)\('
          language: python
          confidence: 0.8
          description: "Python MD5/SHA1 usage"

        - pattern: 'MessageDigest\.getInstance\(["\']MD5["\']\)'
          language: java
          confidence: 0.8
          description: "Java MD5 MessageDigest"

        - pattern: 'MessageDigest\.getInstance\(["\']SHA-1["\']\)'
          language: java
          confidence: 0.8
          description: "Java SHA1 MessageDigest"

    scope:
      file_patterns:
        - "**/*.py"
        - "**/*.java"
        - "**/*.js"
        - "**/*.php"
      languages:
        - python
        - java
        - javascript
        - php

    remediation:
      description: |
        Use slow, adaptive hashing algorithms specifically designed for passwords:
        bcrypt, scrypt, Argon2, or PBKDF2 with high iteration counts.

      steps:
        - "Replace fast hash functions with bcrypt, scrypt, or Argon2"
        - "Use appropriate work factors/iterations (bcrypt cost 12+, PBKDF2 100k+ iterations)"
        - "Use a unique salt for each password (handled automatically by bcrypt/scrypt)"
        - "Never decrypt passwords - always hash and compare"

      code_examples:
        - language: python
          insecure: |
            # INSECURE - Fast hashing algorithm
            import hashlib

            def hash_password(password):
                return hashlib.sha256(password.encode()).hexdigest()

          secure: |
            # SECURE - bcrypt for password hashing
            import bcrypt

            def hash_password(password):
                salt = bcrypt.gensalt(rounds=12)
                return bcrypt.hashpw(password.encode(), salt)

            def verify_password(password, hashed):
                return bcrypt.checkpw(password.encode(), hashed)

    references:
      - "https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html"
      - "https://cwe.mitre.org/data/definitions/326.html"

  # =============================================================================
  # SENSITIVE DATA EXPOSURE
  # =============================================================================

  - rule_id: BUILTIN-DATA-001
    title: "Sensitive Data in Logs"
    description: "Logging of sensitive information such as passwords, tokens, credit cards, or PII"
    severity: HIGH
    category: security
    cwe: CWE-532
    owasp: "A09:2021 - Security Logging and Monitoring Failures"

    compliance:
      - framework: PCI_DSS
        requirement: "3.4"
        description: "Render PAN unreadable anywhere it is stored"
      - framework: PIPEDA
        requirement: "Principle 7"
        description: "Safeguards"
      - framework: HIPAA
        requirement: "164.312(a)(1)"
        description: "Access controls for ePHI"

    detection:
      patterns:
        - pattern: '(log|logger|logging)\.(info|debug|warn|error|critical)\([^)]*password[^)]*\)'
          confidence: 0.85
          description: "Logging password"

        - pattern: '(log|logger|logging)\.(info|debug|warn|error|critical)\([^)]*token[^)]*\)'
          confidence: 0.75
          description: "Logging token"

        - pattern: '(log|logger|logging)\.(info|debug|warn|error|critical)\([^)]*(ssn|social_security)[^)]*\)'
          confidence: 0.9
          description: "Logging SSN"

        - pattern: '(log|logger|logging)\.(info|debug|warn|error|critical)\([^)]*(credit_card|creditcard|card_number)[^)]*\)'
          confidence: 0.9
          description: "Logging credit card"

        - pattern: 'console\.(log|info|debug|warn|error)\([^)]*(password|token|secret)[^)]*\)'
          language: javascript
          confidence: 0.8
          description: "Console logging sensitive data"

    scope:
      file_patterns:
        - "**/*.py"
        - "**/*.js"
        - "**/*.java"
        - "**/*.go"
        - "**/*.rb"
        - "**/*.php"
        - "**/*.ts"
      languages:
        - python
        - javascript
        - java
        - go
        - ruby
        - php
        - typescript

    remediation:
      description: |
        Never log sensitive information. Redact or mask sensitive fields before logging.
        Log only non-sensitive contextual information for debugging.

      steps:
        - "Review all logging statements for sensitive data"
        - "Redact or mask sensitive fields (show only last 4 digits of cards)"
        - "Use structured logging with field-level control"
        - "Implement log sanitization functions"

      code_examples:
        - language: python
          insecure: |
            # INSECURE - Logging sensitive data
            logger.info(f"User login: username={username}, password={password}")
            logger.debug(f"API request with token: {api_token}")

          secure: |
            # SECURE - Logging without sensitive data
            logger.info(f"User login: username={username}")
            logger.debug(f"API request authenticated")

            # If you must log tokens for debugging, redact them
            def redact_token(token):
                if len(token) > 8:
                    return token[:4] + "****" + token[-4:]
                return "****"

            logger.debug(f"API request with token: {redact_token(api_token)}")

    references:
      - "https://cwe.mitre.org/data/definitions/532.html"
      - "https://owasp.org/www-community/vulnerabilities/Information_exposure_through_query_strings_in_url"

  - rule_id: BUILTIN-DATA-002
    title: "Cleartext Transmission of Sensitive Data"
    description: "Sensitive data transmitted over unencrypted HTTP connection"
    severity: HIGH
    category: security
    cwe: CWE-319
    owasp: "A02:2021 - Cryptographic Failures"

    compliance:
      - framework: PCI_DSS
        requirement: "4.1"
        description: "Use strong cryptography and security protocols to safeguard sensitive cardholder data during transmission"
      - framework: HIPAA
        requirement: "164.312(e)(1)"
        description: "Transmission security for ePHI"

    detection:
      patterns:
        - pattern: 'http://[^/]*\.(payment|checkout|login|auth|api)'
          confidence: 0.9
          description: "HTTP URL for sensitive endpoint"

        - pattern: 'requests\.(get|post|put|delete)\(["\']http://'
          language: python
          confidence: 0.7
          description: "Python HTTP request"

        - pattern: 'verify\s*=\s*False'
          language: python
          confidence: 0.8
          description: "Disabled SSL verification in Python"

        - pattern: 'strictSSL:\s*false'
          language: javascript
          confidence: 0.8
          description: "Disabled SSL verification in JavaScript"

    scope:
      file_patterns:
        - "**/*.py"
        - "**/*.js"
        - "**/*.java"
        - "**/*.go"
      languages:
        - python
        - javascript
        - java
        - go

    remediation:
      description: |
        Always use HTTPS (TLS 1.2+) for transmitting sensitive data. Never disable
        SSL/TLS verification in production.

      steps:
        - "Use HTTPS URLs for all sensitive data transmission"
        - "Enforce TLS 1.2 or higher"
        - "Enable SSL/TLS certificate verification"
        - "Implement HSTS headers"

      code_examples:
        - language: python
          insecure: |
            # INSECURE - HTTP and disabled verification
            response = requests.post(
                'http://api.example.com/payment',
                json={'card_number': card},
                verify=False
            )

          secure: |
            # SECURE - HTTPS with verification
            response = requests.post(
                'https://api.example.com/payment',
                json={'card_number': card},
                verify=True  # Default, but explicit is good
            )

    references:
      - "https://cwe.mitre.org/data/definitions/319.html"
      - "https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html"

  # =============================================================================
  # ACCESS CONTROL
  # =============================================================================

  - rule_id: BUILTIN-ACCESS-001
    title: "Missing Authorization Check"
    description: "Endpoint or function lacks authorization verification after authentication"
    severity: HIGH
    category: security
    cwe: CWE-862
    owasp: "A01:2021 - Broken Access Control"

    compliance:
      - framework: PCI_DSS
        requirement: "7.1"
        description: "Limit access to system components and cardholder data to only those individuals whose job requires such access"
      - framework: SOC2
        requirement: "CC6.1"
        description: "Logical and physical access controls"

    detection:
      patterns:
        - pattern: '@(app\.route|router\.(get|post|put|delete))\([^\)]*\)[^@]*\ndef [^(]*\([^)]*\):[^@]*(?!@(requires_auth|login_required|permission_required))'
          language: python
          confidence: 0.6
          description: "Flask/FastAPI route without auth decorator"

        - pattern: '@RequestMapping[^@]*public [^{]*\{(?!.*hasRole|.*hasAuthority)'
          language: java
          confidence: 0.5
          description: "Spring endpoint without authorization"

    scope:
      file_patterns:
        - "**/*.py"
        - "**/*.java"
        - "**/*.js"
        - "**/*.ts"
      languages:
        - python
        - java
        - javascript
        - typescript

    remediation:
      description: |
        Always verify user authorization for protected resources. Check not just
        authentication (who you are) but authorization (what you can access).

      steps:
        - "Add authorization checks to all protected endpoints"
        - "Implement role-based access control (RBAC)"
        - "Verify user owns/can access the requested resource"
        - "Use framework authorization decorators/middleware"
        - "Default deny - require explicit permission grants"

      code_examples:
        - language: python
          insecure: |
            # INSECURE - Missing authorization check
            @app.route('/api/user/<user_id>/profile', methods=['GET'])
            @login_required  # Only checks authentication
            def get_user_profile(user_id):
                user = User.query.get(user_id)
                return jsonify(user.to_dict())

          secure: |
            # SECURE - Authorization check added
            @app.route('/api/user/<user_id>/profile', methods=['GET'])
            @login_required
            def get_user_profile(user_id):
                user = User.query.get(user_id)

                # Authorization check - can current user access this profile?
                if current_user.id != user.id and not current_user.is_admin:
                    abort(403)  # Forbidden

                return jsonify(user.to_dict())

    references:
      - "https://cwe.mitre.org/data/definitions/862.html"
      - "https://owasp.org/Top10/A01_2021-Broken_Access_Control/"

  - rule_id: BUILTIN-ACCESS-002
    title: "Path Traversal Vulnerability"
    description: "File operations with unsanitized user input allow directory traversal"
    severity: HIGH
    category: security
    cwe: CWE-22
    owasp: "A01:2021 - Broken Access Control"

    detection:
      patterns:
        - pattern: 'open\([^)]*\+[^)]*\)'
          language: python
          confidence: 0.7
          description: "File open with concatenation"

        - pattern: 'File\([^)]*\+[^)]*\)'
          language: java
          confidence: 0.7
          description: "Java File with concatenation"

        - pattern: 'readFile\([^)]*\+[^)]*\)'
          language: javascript
          confidence: 0.7
          description: "Node.js readFile with concatenation"

    scope:
      file_patterns:
        - "**/*.py"
        - "**/*.java"
        - "**/*.js"
        - "**/*.php"
      languages:
        - python
        - java
        - javascript
        - php

    remediation:
      description: |
        Validate and sanitize file paths. Use allowlists for allowed files/directories.
        Resolve paths and ensure they stay within allowed boundaries.

      steps:
        - "Validate filename against strict allowlist/pattern"
        - "Use os.path.abspath() and verify it's within allowed directory"
        - "Remove or reject path traversal sequences (../, ../../, etc.)"
        - "Use file identifiers instead of filenames when possible"

      code_examples:
        - language: python
          insecure: |
            # INSECURE - Path traversal vulnerability
            filename = request.args.get('file')
            with open(f'/var/www/uploads/{filename}', 'r') as f:
                content = f.read()

          secure: |
            # SECURE - Path validation
            import os

            filename = request.args.get('file')

            # Validate filename
            if not re.match(r'^[a-zA-Z0-9_\-\.]+$', filename):
                abort(400, "Invalid filename")

            # Resolve full path and verify it's within allowed directory
            base_dir = os.path.abspath('/var/www/uploads')
            file_path = os.path.abspath(os.path.join(base_dir, filename))

            if not file_path.startswith(base_dir):
                abort(400, "Invalid file path")

            with open(file_path, 'r') as f:
                content = f.read()

    references:
      - "https://cwe.mitre.org/data/definitions/22.html"
      - "https://owasp.org/www-community/attacks/Path_Traversal"

  # =============================================================================
  # CRYPTOGRAPHY
  # =============================================================================

  - rule_id: BUILTIN-CRYPTO-001
    title: "Insecure Random Number Generation"
    description: "Use of non-cryptographic random functions for security-sensitive operations"
    severity: MEDIUM
    category: security
    cwe: CWE-338
    owasp: "A02:2021 - Cryptographic Failures"

    detection:
      patterns:
        - pattern: 'random\.(random|randint|choice|shuffle)(?!.*# nosec)'
          language: python
          confidence: 0.7
          description: "Python random module (not cryptographically secure)"

        - pattern: 'Math\.random\('
          language: javascript
          confidence: 0.7
          description: "JavaScript Math.random (not cryptographically secure)"

        - pattern: 'new Random\('
          language: java
          confidence: 0.7
          description: "Java Random class (not cryptographically secure)"

    scope:
      file_patterns:
        - "**/*.py"
        - "**/*.js"
        - "**/*.java"
      languages:
        - python
        - javascript
        - java

    remediation:
      description: |
        Use cryptographically secure random number generators for security-sensitive
        operations like token generation, session IDs, or cryptographic keys.

      steps:
        - "Replace random with secrets module (Python)"
        - "Use crypto.randomBytes (Node.js) or Web Crypto API (browser)"
        - "Use SecureRandom class (Java)"

      code_examples:
        - language: python
          insecure: |
            # INSECURE - Predictable random
            import random
            token = ''.join(random.choices('0123456789abcdef', k=32))

          secure: |
            # SECURE - Cryptographically secure random
            import secrets
            token = secrets.token_hex(16)

        - language: javascript
          insecure: |
            // INSECURE - Predictable random
            function generateToken() {
                return Math.random().toString(36).substring(2);
            }

          secure: |
            // SECURE - Cryptographically secure random
            const crypto = require('crypto');
            function generateToken() {
                return crypto.randomBytes(16).toString('hex');
            }

    references:
      - "https://cwe.mitre.org/data/definitions/338.html"

  # =============================================================================
  # API SECURITY
  # =============================================================================

  - rule_id: BUILTIN-API-001
    title: "Missing API Rate Limiting"
    description: "API endpoint lacks rate limiting, vulnerable to brute force and DoS"
    severity: MEDIUM
    category: api_security
    cwe: CWE-770
    owasp: "A04:2021 - Insecure Design"

    compliance:
      - framework: PCI_DSS
        requirement: "8.2.4"
        description: "Lockout after repeated access attempts"

    detection:
      patterns:
        - pattern: '@(app\.route|router\.(get|post))\(["\']/(api|v1|v2)/'
          confidence: 0.5
          description: "API route definition"

    scope:
      file_patterns:
        - "**/*.py"
        - "**/*.js"
        - "**/*.ts"
      languages:
        - python
        - javascript
        - typescript

    remediation:
      description: |
        Implement rate limiting on all API endpoints to prevent brute force attacks
        and denial of service. Use stricter limits on authentication endpoints.

      steps:
        - "Implement rate limiting middleware (Flask-Limiter, express-rate-limit)"
        - "Use stricter limits on authentication/sensitive endpoints"
        - "Rate limit per user, per IP, and globally"
        - "Return 429 Too Many Requests with Retry-After header"

      code_examples:
        - language: python
          insecure: |
            # INSECURE - No rate limiting
            @app.route('/api/login', methods=['POST'])
            def login():
                username = request.json.get('username')
                password = request.json.get('password')
                # Authentication logic...

          secure: |
            # SECURE - Rate limiting added
            from flask_limiter import Limiter
            from flask_limiter.util import get_remote_address

            limiter = Limiter(
                app,
                key_func=get_remote_address,
                default_limits=["200 per day", "50 per hour"]
            )

            @app.route('/api/login', methods=['POST'])
            @limiter.limit("5 per minute")  # Strict limit on authentication
            def login():
                username = request.json.get('username')
                password = request.json.get('password')
                # Authentication logic...

    references:
      - "https://cwe.mitre.org/data/definitions/770.html"
      - "https://owasp.org/API-Security/editions/2023/en/0xa4-unrestricted-resource-consumption/"

  # =============================================================================
  # CONFIGURATION & DEPLOYMENT
  # =============================================================================

  - rule_id: BUILTIN-CONFIG-001
    title: "Debug Mode Enabled"
    description: "Debug mode enabled in configuration, exposing sensitive information in production"
    severity: MEDIUM
    category: security
    cwe: CWE-489
    owasp: "A05:2021 - Security Misconfiguration"

    compliance:
      - framework: PCI_DSS
        requirement: "6.5.5"
        description: "Improper error handling"

    detection:
      patterns:
        - pattern: 'DEBUG\s*=\s*True'
          language: python
          confidence: 0.8
          description: "Django/Flask DEBUG=True"

        - pattern: 'debug:\s*true'
          confidence: 0.7
          description: "Debug enabled in YAML config"

        - pattern: 'NODE_ENV.*development'
          language: javascript
          confidence: 0.6
          description: "Node.js development mode"

    scope:
      file_patterns:
        - "**/*.py"
        - "**/*.yml"
        - "**/*.yaml"
        - "**/*.json"
        - "**/*.js"
      exclude:
        - "**/test/**"
        - "**/local/**"
        - "**/*.local.*"

    remediation:
      description: |
        Never enable debug mode in production. Use environment-specific configuration
        and ensure debug is disabled for production deployments.

      steps:
        - "Set DEBUG=False in production configuration"
        - "Use environment variables for configuration"
        - "Implement custom error pages for production"
        - "Log errors server-side without exposing to users"

      code_examples:
        - language: python
          insecure: |
            # INSECURE - Debug hardcoded to True
            DEBUG = True
            app.run(debug=DEBUG)

          secure: |
            # SECURE - Debug from environment
            import os
            DEBUG = os.environ.get('DEBUG', 'False').lower() == 'true'
            app.run(debug=DEBUG)

    references:
      - "https://cwe.mitre.org/data/definitions/489.html"

  - rule_id: BUILTIN-CONFIG-002
    title: "Missing Security Headers"
    description: "Missing HTTP security headers that protect against common attacks"
    severity: LOW
    category: security
    cwe: CWE-693
    owasp: "A05:2021 - Security Misconfiguration"

    detection:
      patterns:
        - pattern: '@app\.(route|get|post)'
          confidence: 0.3
          description: "Web route definition - check for security headers"

    scope:
      file_patterns:
        - "**/*.py"
        - "**/*.js"
      languages:
        - python
        - javascript

    remediation:
      description: |
        Implement security headers to protect against clickjacking, XSS, and other attacks.

      recommended_headers:
        - "Content-Security-Policy: default-src 'self'"
        - "X-Content-Type-Options: nosniff"
        - "X-Frame-Options: DENY"
        - "X-XSS-Protection: 1; mode=block"
        - "Strict-Transport-Security: max-age=31536000; includeSubDomains"

      code_examples:
        - language: python
          secure: |
            # Flask example with security headers
            from flask import Flask
            from flask_talisman import Talisman

            app = Flask(__name__)
            Talisman(app,
                content_security_policy={
                    'default-src': "'self'",
                    'script-src': "'self' 'unsafe-inline'",
                    'style-src': "'self' 'unsafe-inline'"
                },
                force_https=True
            )

    references:
      - "https://owasp.org/www-project-secure-headers/"

# End of built-in rules
# Total rules: 17 (covering most critical vulnerability types)
# For additional rules, create custom rules in your project's security-rules/ directory
